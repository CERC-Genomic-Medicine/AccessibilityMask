import pandas as pd
import sys
import argparse

argparser = argparse.ArgumentParser(description = 
 'This script makes bed files from depth files generated by coverage pipeline!')

argparser.add_argument('-i', '--input-file', metavar = 'file', dest = 'in_path', type = str, required = True, help = 'File containing coverage of each variant and percent of individuals havingthat variant with specified coverage.')
argparser.add_argument('-dp', '--min-dp', metavar = 'number', dest = 'in_depth', type = int, required = True, help = 'Minimum depth considering as high coverage threshold, must be one of the elements of following list [5X, 10X, 15X, 20X, 25X, 30X, 50X, 100X, 0X].')
argparser.add_argument('-ind', '--pct-ind', metavar = 'number', dest = 'in_pct', type = int, required = True, help = 'Minimum percentile of individuals with the mentioned depth threshold, should be between 0 and 1.')
argparser.add_argument('-o', '--output', metavar = 'file', dest = 'out_file_path', type = str, required = True, help = 'Output bed file containing high coverage files.')

def load_coverage_data(path = '/path/to/depth/data', min_depth = "10X", min_percent = 1):
    flag = 0
    pos_list = []
    if ((min_percent > 1) or (min_percent < 0)):
        raise Exception("minimal percentile of individuals over minimum depth should be between 0 and 1.")
        
    column_name = f'PCT_INDV_OVER_{min_depth}'
        
    with open(path, 'r') as file:
        header = file.readline().rstrip().split()
        if column_name not in header:
            raise Exception(f'{column_name} is not in the header.')
        chrom_colindex = header.index('CHROM') 
        bp_colindex = header.index('BP')
        dp_colindex = header.index(column_name)
        
        for line in file:
            columns = line.rstrip().split()
            chrom = columns[chrom_colindex]
            bp = int(columns[bp_colindex]) - 1
            dp = float(columns[dp_colindex])


            if (min_depth == "5X"):
                if(dp == min_percent):
                    pos_list.append(bp)
            elif (min_depth == "10X"):
                if(dp == min_percent):
                    pos_list.append(bp)
            elif (min_depth == "15X"):
                if(dp == min_percent):
                    pos_list.append(bp)
            elif (min_depth == "20X"):
                if(dp == min_percent):
                    pos_list.append(bp)
            elif (min_depth == "25X"):
                if(dp == min_percent):
                    pos_list.append(bp)
            elif (min_depth == "30X"):
                if(dp == min_percent):
                    pos_list.append(bp)
            elif (min_depth == "50X"):
                if(dp == min_percent):
                    pos_list.append(bp)
            elif (min_depth == "100X"):
                if(dp == min_percent):
                    pos_list.append(bp)
            elif (min_depth == "0X"):
                    pos_list.append(bp)
            else:
                raise Exception("Chosen min-depth is not permited, please ensure that your min-depth is in following list [5X, 10X, 15X, 20X, 25X, 30X, 50X, 100X],\
                you can also choose 0X in case that you want to work with all variants.")

        pos_list = sorted(set(pos_list))
        range_start = previous_number = pos_list[0]

        for number in pos_list[1:]:
            if number == previous_number + 1:
                previous_number = number
            else:
                yield {"CHROM": chrom, "start" : range_start, "end" : previous_number}
                range_start = previous_number = number

        yield {"CHROM": chrom, "start" : range_start, "end" : previous_number}


if __name__ == "__main__":
    args = argparser.parse_args()
    depth_file = args.in_path
    min_depth = args.in_depth
    pct_ind = args.in_pct
    out_file_path = args.out_file_path
    intervals = pd.DataFrame(load_coverage_data(depth_file, min_depth, pct_ind))
    intervals.to_csv(out_file_path, sep="/t", index=False)
    exit()
    